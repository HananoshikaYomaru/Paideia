---
description: error handling with typescript result
globs:
alwaysApply: true
---


## Getting started

## Installation

### Requirements

#### Typescript

Technically Typescript with version `4.8.0` or higher should work, but we recommend using version >= `5` when possible.

Also it is important that you have `strict` or `strictNullChecks` enabled in your `tsconfig.json`:

```json
json{

  "compilerOptions": {

    "strict": true

  }

}
```

#### Node

Tested with [Node.js](https://nodejs.org/) version `16` and higher.

### Install the library

You can install the library using your favorite package manager.

```sh
sh$ npm add typescript-result
```
```sh
sh$ pnpm add typescript-result
```
```sh
sh$ yarn add typescript-result
```
```sh
sh$ bun add typescript-result
```

## Your first Result

Let's start by refactoring a function that reads a file and parses its content:

```typescript
typescriptfunction readConfig(filePath: string): Config {

  const contents = fs.readFileSync(filePath, "utf-8");

  return JSON.parse(contents);

}
```

This code has a serious flaw: multiple things can go wrong, but the function signature gives no indication of this. The consumer expects this function to always return a `Config` object, but what happens when the file doesn't exist? What if the contents aren't valid JSON? What if the JSON structure doesn't match the expected `Config` shape?

Let's refactor this code using a `Result` type to make these potential failures **explicit**.

First, we need to define some errors so that we can distinguish between different error cases:

```ts
tsclass IOError extends Error {

  readonly type = "io-error";

}

class ParseError extends Error {

  readonly type = "parse-error";

}

class ValidationError extends Error {

  readonly type = "validation-error";

}
```

INFO

Please disregard the `readonly type` property in the error classes for now. It's not necessary for the library to work, but it can be useful for type narrowing and debugging purposes. For more information, see [A note on errors](https://www.typescript-result.dev/a-note-on-errors).

### Returning a Result

With these error classes in place, we can now express the *outcome* of the `readConfig` function as a `Result` type. In case of a caught error, we will return a `Result.error()` with the appropriate error. In case of success, we will return a `Result.ok()` with the parsed configuration object.

```typescript
typescripttype  = {

  : string;

  : number;

}

function (: string) {

  let : string;

  try {

     = fs.(, "utf-8");

  } catch () {

    return .(

      new (\`Unable to read file: ${}\`, { :  })

    );

  }

  let : unknown;

  try {

     = .();

  } catch () {

    return .(

      new (\`Unable to parse JSON from file: ${}\`)

    );

  }

  try {

    const  = ();

    return .();

  } catch () {

    return .(

      new (

        \`Invalid configuration in file: ${}\`, 

        { :  }

      )

    );

  }

}

const  = ("config.json");
```

If you look at the final `result`, you'll see exactly what the outcome of the function can be. And while technically the above code is correct, it is very verbose. Luckily, the library provides a way to make this code more concise.

### Adding the Result.try helper

First, we will introduce the `Result.try` helper function. This function is basically a wrapper around the `try/catch` block that allows us to handle errors in a more concise way. It tries to execute the provided function and wrap the returned value in a `Result.ok()`, or catch any errors and wrap them in a `Result.error()`. Optionally, you can provide a second callback function that allows you to transform the error before wrapping it in a `Result.error()`. Let's see how this looks:

```typescript
typescriptfunction (: string) {

  const  = .(

    () => fs.(, "utf-8"),

    () => new (\`Unable to read file: ${}\`, { :  })

  );

  if (!.) {

    return ;

  }

  const  = .(

    () => .(.),

    () => new (\`Unable to parse JSON from file: ${}\`)

  );

  if (!.) {

    return ;

  }

  

  const  = .(

    () => (.),

    () => new (

      \`Invalid configuration in file: ${}\`, 

      { :  }

    )

  );

  return ;

}
```

### Extracting steps with Result.wrap

Ok, no more `try/catch` blocks, but the code is still very verbose. To improve readability, we can extract each step into a separate function. This will allow us to focus on the main logic of the `readConfig` function without getting lost in the details of error handling. This is where `Result.wrap` comes in handy. This is very similar to `Result.try`, but instead of executing a function directly, it returns a function instead:

```typescript
typescriptconst  = .(

  (: string) => fs.(, "utf-8"),

  () => new (\`Unable to read file\`, { :  }),

);

const  = .(

  (: string) => .() as unknown,

  () => new (\`Unable to parse JSON\`)

);

const  = .(

  (: unknown) => {

    /* skipped for brevity */

    return  as ;

  },

  () => new (\`Invalid configuration\`, { :  }),

);

function (: string) {

  const  = ();

  if (!.) {

    return ;

  }

  const  = (.);

  if (!.) {

    return ;

  }

  

  return (.);

}
```

### Chaining operations

This is a step in the right direction, but we can still improve the code further. Did you notice how we check for errors after each step? This is a pattern both loved and hated in languages like Go. While it makes things explicit, it can also lead to a lot of boilerplate code. To make our code more ergonomic, we can introduce *chaining*: performing multiple operations on a `Result` instance in a more concise way. In 90% of the cases `Result.map()` is the method you want to use. Let's see how this works in practice:

```typescript
typescriptfunction (: string) {

  return ()

    .(() => ())

    .(() => ());

}
```

INFO

Most operations on `Result` instances are polymorphic, meaning you can return different types of values from them â€” literal values, promises, or even other `Result` instances as shown above. This flexibility makes it easy to compose operations and build complex workflows.

TIP

If you have worked with `typescript-result` for a while, you'll notice that often there are multiple ways to achieve the same result. This is intentional, as we want to provide you with the flexibility to choose the approach that best fits your use case. The library is designed to be ergonomic and easy to use, so you can focus on writing clean and maintainable code.

To illustrate this point, we could have 'inlined' the json parsing using `mapCatching` for instance, instead of extracting it into a separate function:

```typescript
typescriptfunction readConfig(filePath: string) {

  return readFile(filePath)

    .mapCatching(

      (contents) => JSON.parse(contents),

      () => new ParseError(\`Unable to parse JSON\`)

    )

    .map((json) => parseConfig(json));

}
```

### (Optional) 'do-style' syntax using generators

Remember this pattern from a few examples back?

```typescript
typescriptconst result = operation();

if (!result.ok) {

  return result;

}
```

With Rust you can use the [`?` operator](https://doc.rust-lang.org/rust-by-example/std/result/question_mark.html) to make this more concise, but in TypeScript we don't have that luxury. However, we can use generator functions to achieve a similar effect. This is an optional feature of the library, and you can choose to use it or not. For more information, see [Chaining vs. generator syntax](https://www.typescript-result.dev/chaining-vs-generator-syntax#using-generators).

Here's a quick example of how this works:

```typescript
typescriptfunction* (: string) {

  const  = yield* ();

  const  = yield* ();

  const  = yield* ();

  return ;

}

const  = .(("config.json"));
```

Hopefully this gives you a good idea of how to get started with `typescript-result`. For more information on how to use this library, please continue with the [guide](https://www.typescript-result.dev/a-note-on-errors). If you want to see more examples, check out the [examples](https://www.typescript-result.dev/examples/). Ready to give it a spin? Try it out for yourself in our [playground](https://www.typescript-result.dev/playground).